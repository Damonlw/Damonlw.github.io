webpackJsonp([2,0],[function(t,n,e){"use strict";function a(t){return t&&t.__esModule?t:{default:t}}var s=e(3),p=a(s),o=e(40),r=a(o),i=e(14),u=a(i),l=e(22),c=a(l),d=e(15),f=a(d),m=e(16),g=a(m);p.default.use(c.default);var v=[{path:"/",component:f.default},{path:"/:id",component:g.default}],h=new c.default({routes:v});new p.default({el:"#app",router:h,store:r.default,template:"<App/>",components:{App:u.default}})},,,,,,,,function(t,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.GET_DATA="GET_DATA"},function(t,n,e){t.exports=e.p+"static/img/Tony.95aaee3.png"},function(t,n){},function(t,n){},function(t,n){},function(t,n){},function(t,n,e){var a,s;e(12),a=e(35);var p=e(20);s=a=a||{},"object"!=typeof a.default&&"function"!=typeof a.default||(s=a=a.default),"function"==typeof s&&(s=s.options),s.render=p.render,s.staticRenderFns=p.staticRenderFns,t.exports=a},function(t,n,e){var a,s;e(11),a=e(36);var p=e(19);s=a=a||{},"object"!=typeof a.default&&"function"!=typeof a.default||(s=a=a.default),"function"==typeof s&&(s=s.options),s.render=p.render,s.staticRenderFns=p.staticRenderFns,s._scopeId="data-v-3d1f5143",t.exports=a},function(t,n,e){var a,s;e(10),a=e(37);var p=e(18);s=a=a||{},"object"!=typeof a.default&&"function"!=typeof a.default||(s=a=a.default),"function"==typeof s&&(s=s.options),s.render=p.render,s.staticRenderFns=p.staticRenderFns,t.exports=a},function(t,n,e){var a,s;e(13),a=e(38);var p=e(21);s=a=a||{},"object"!=typeof a.default&&"function"!=typeof a.default||(s=a=a.default),"function"==typeof s&&(s=s.options),s.render=p.render,s.staticRenderFns=p.staticRenderFns,t.exports=a},function(t,n){t.exports={render:function(){var t=this,n=(t.$createElement,t._c);return n("div",{staticClass:"container"},[n("article",{staticClass:"content"},[n("div",{staticClass:"blue-strip"}),t._v(" "),n("span",{staticClass:"type",domProps:{textContent:t._s(t.describe)}}),t._v(" "),n("h2",{domProps:{textContent:t._s(t.title)}}),t._v(" "),n("section",{class:["section-content",{center:t.isCenter}],domProps:{innerHTML:t._s(t.data)}}),t._v(" "),n("footer",{staticClass:"copy-right"},[t._v("\n\t\t\tCopyright © 2016 老外 · 关于本站 · Powered by GitHub · Design by 老外\n\t\t")]),t._v(" "),n("div",{staticClass:"blue-one"}),t._v(" "),n("div",{staticClass:"blue-two"})])])},staticRenderFns:[]}},function(t,n){t.exports={render:function(){var t=this,n=(t.$createElement,t._c);return n("div",{staticClass:"container"},t._l(t.Items,function(e){return n("article",{staticClass:"content"},[n("div",{staticClass:"blue-strip"}),t._v(" "),n("span",{staticClass:"type",domProps:{textContent:t._s(e.type)}}),t._v(" "),n("h2",{domProps:{textContent:t._s(e.title)}}),t._v(" "),n("section",{staticClass:"section-content"},t._l(e.pItems,function(e){return n("p",{domProps:{textContent:t._s(e.pText)}})})),t._v(" "),n("footer",[n("a",{on:{click:function(n){t.goDetail(e.title)}}},[t._v("Read More")])]),t._v(" "),n("div",{staticClass:"blue-one"}),t._v(" "),n("div",{staticClass:"blue-two"})])}))},staticRenderFns:[]}},function(t,n){t.exports={render:function(){var t=this,n=(t.$createElement,t._c);return n("div",{attrs:{id:"app"}},[n("navigation"),t._v(" "),n("transition",{attrs:{name:"slide-fade"}},[n("router-view")])])},staticRenderFns:[]}},function(t,n,e){t.exports={render:function(){var t=this,n=(t.$createElement,t._c);return n("div",{staticClass:"nav"},[n("div",{staticClass:"nav-content"},[n("ul",{staticClass:"nav-content-ul"},[n("li",{on:{click:t.goHome}},[t._v("Home")]),t._v(" "),t._m(0)]),t._v(" "),t._m(1)])])},staticRenderFns:[function(){var t=this,n=(t.$createElement,t._c);return n("li",[n("a",{staticClass:"github-style",attrs:{href:"https://github.com/Damonlw",target:"_blank"}},[t._v("Github")])])},function(){var t=this,n=(t.$createElement,t._c);return n("div",{staticClass:"headtrait"},[n("div",{staticClass:"head-overflow",attrs:{"data-title":"I'm shouldn't alive, unless was a reason."}},[n("img",{attrs:{src:e(9)}})]),t._v(" "),n("span",[t._v("老外")])])}]}},,,,,,,,,,,,,,function(t,n,e){"use strict";function a(t){return t&&t.__esModule?t:{default:t}}Object.defineProperty(n,"__esModule",{value:!0});var s=e(17),p=a(s);n.default={name:"app",components:{navigation:p.default}}},function(t,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default={data:function(){return{Items:[{type:"#奇说怪谈",title:"Future",pItems:[{pText:"You have to trust in something - your gut, destiny, life, karma, whatever，"},{pText:"Stay Hungry. Stay Foolish."},{pText:"..."}]},{type:"#函数式编程",title:"函数式编程简介",pItems:[{pText:"也许会是未来的趋势，"},{pText:"吸引人的引用透明性和可复用性，"},{pText:"以及方便测试构建等，"},{pText:"..."}]},{type:"#JavaScript",title:"JavaScript之原型篇",pItems:[{pText:"人脑非机器，"},{pText:"时间久后，记忆都会退化，"},{pText:"因此需要文档辅助作知识沉淀，"},{pText:"..."}]},{type:"#Vue",title:"Vue 2.0双向绑定",pItems:[{pText:"Vue是一个我比较喜欢的框架，轻快简洁，"},{pText:"除vue外，我也喜欢React,"},{pText:"本想写更多点内容，只是vue官网写得蛮好的，而且是中文，就没感觉没必要,"},{pText:"废话不多说，走起，走起，"},{pText:"..."}]},{type:"#ES6",title:"ECMAScript 6之艺术篇",pItems:[{pText:"人脑非机器，"},{pText:"时间久后，记忆都会退化，"},{pText:"因此需要文档辅助作知识沉淀，"},{pText:"..."}]}]}},methods:{goDetail:function(t){this.$router.push("/"+t),this.$store.dispatch("getData",{title:t,top:document.body.scrollTop}),document.body.scrollTop=0}}}},function(t,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default={data:function(){return{isCenter:!1}},computed:{describe:function(){return this.$store.state.finalData.type},title:function(){return this.$store.state.finalData.title},data:function(){return this.$store.state.finalData.content},isCenter:function(){return this.$store.state.finalData.isCenter}}}},function(t,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default={data:function(){return{isChangeNav:!0,isChangeA:!0}},methods:{goHome:function(){this.$router.push("/"),document.body.scrollTop=this.$store.state.scrollTop}}}},function(t,n,e){"use strict";function a(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var e in t)Object.prototype.hasOwnProperty.call(t,e)&&(n[e]=t[e]);return n.default=t,n}Object.defineProperty(n,"__esModule",{value:!0});var s=e(8),p=a(s);n.default={getData:function(t,n){var e=t.commit;e(p.GET_DATA,n)}}},function(t,n,e){"use strict";function a(t){return t&&t.__esModule?t:{default:t}}Object.defineProperty(n,"__esModule",{value:!0});var s=e(3),p=a(s),o=e(23),r=a(o),i=e(41),u=a(i),l=e(39),c=a(l);p.default.use(r.default);var d={scrollTop:0,finalData:"",function:{type:"#函数式编程",isCenter:!0,title:"函数式编程简介",content:"<p>    常见的编程范式有4种：命令式、逻辑式、面向对象及函数式。函数式则更接近于数学，即对表达式求值，与面向对象有所不同的是函数式是对问题的抽象方法是抽象成带有动作的函数。函数式也同面向对象一样还包含了很多概念，比如高阶函数，不可变性，惰性求值等。</p>\n\t<p><strong>函数式的标志:</strong></p>\n\t<ul><li>\n\t高阶函数</li>\n\t<li>\n\t函数组合</li>\n\t<li>\n\t箭头函数等ES6特性</li>\n\t<li>\n\t尾递归 </li>\n\t</ul>\n\t<p><strong>纯函数</strong></p>\n\t<p>  即函数只处理传入的参数。以下的add函数没有访问变量z，只访问参数x, y，并返回他们相加的结果。若访问了变量z，它将不再是纯函数。</p>\n\t<pre lang='undefined'>\n\t<span>var</span> z = 10;\n\t<span>function</span> add(x, y){\n\t  <span>return</span> x + y\n\t}\n\t</pre>\n\t<p><strong>持久性且不可变的数据结构</strong></p>\n\t<p>  顾名思义即任何操作都不会改变该数据结构，在JavaScript中除了原始类型（Boolean，Null，Undefind，Number，String，Symbol），其他都是可变的。</p>\n\t<pre lang='undefined'>\n\t<span>const</span> arr = [1, 2, 3]\n\tarr.<span>push</span>(4) // [1, 2, 3, 4] 数组的值已经被改变\n\t</pre>\n\t<p>  再例如魔术环节中的帽子戏法变鸽子。过程为先让一只叫tweety的鸽子从帽子消失，暂时变出一只叫翠花的鸽子，再把原来的tweety鸽子从帽子里变回来。</p>\n\t<pre lang='undefined'>\n\t<span>const</span> magic = cage =&gt; cage[0] = { name: &#39;翠花&#39; }\n\t<span>const</span> birdInACage = [{name: &#39;tweety&#39;}]\n\tmagic(birdInACage)\n\tbirdInACage     // [{ name: &#39;翠花&#39; }]\n\t</pre>\n\t<p>上面我们通过魔术帽让tweety的鸽子消失，但是tweety真的消失了，无法再变回来，因为同个引用指向的值已经变为翠花。</p>\n\t<p>  接着我们在魔术上动下手脚，再变一次，如下代码：</p>\n\t<pre lang='undefined'>\n\t<span>const</span> birdInACage = [{name: &#39;tweety&#39;}]\n\t<span>const</span> magic = birdInACage =&gt; birdInACage.<span>map</span>(bird =&gt;({ name: &#39;翠花&#39; }))\n\t<span>const</span> another = magic(birdInACage)\n\tconsole.log(another)     // [{ name: &#39;翠花&#39; }]\n\tconsole.log(birdInACage)     // [{ name: &#39;tweety&#39; }]\n\t</pre>\n\t<p>经过改良后，发现把tweety变消失，并变出翠花，如同魔术师做了手脚隐藏切换两只鸽子。这体现了持久不可变性。</p>\n\t<p></p>\n\t<p><strong>尾递归</strong></p>\n\t<p>数据不可变，循环照样有手段解决！要么通过filter，reduce，map，sort等进行解决，或者通过尾递归来解决。比如下面这个例子：</p>\n\t<pre lang='undefined'>\n\t<span>var</span> acc = 0;\n\tfor (<span>var</span> i = 1; i &lt;= 10; ++i)\n\t    acc += i;\n\tconsole.log(acc)  // 55\n\n\t<span>const</span> sum = (start, end, acc) =&gt;{\n\t\tif(start &gt; end)\n\t\t<span>return</span> acc;\n\t\t<span>return</span> sum(start + 1, end, acc + start)\n\t}\n\tsum(1, 10, 0) // 55\n\t</pre>\n\t<p></p>\n\t<p><strong>函数组合</strong></p>\n\t<p>  这个同数学中的f(g(x))类似，函数组合涉及到柯里化，闭包，自由变量与约束变量。把可变的转换成参数或者函数参数，而约束变量同上面递归中的次数大小作为参数传入一样。</p>\n\t<p>柯里化就是把一个多参的函数变成一次只能接受一个参数的函数过程。如下例子：</p>\n\t<pre lang='undefined'>\n\t<span>const</span> pair = a =&gt; b =&gt; [a, b]\n\tpair(1)(2)  //  [1, 2]\n\t</pre>\n\t<p>如下体现通过组合使得结果唯一，但同时具备引用透明性，独立函数本身。执行顺序固定，不会因为执行顺序导致结果可变。</p>\n\t<pre lang=' '>\n\t<span>const</span> add = val =&gt; val + 10;\n\t<span>const</span> mult = val =&gt; val * 5;\n\n\t<span>const</span> multAfterAdd = val =&gt; mult(add(val));\n\t<span>const</span> addAfterMult = val =&gt; add(mult(val));\n\n\tconsole.log(multAfterAdd(10)); // 100\n\tconsole.log(addAfterMult(10)); // 60\n\t</pre>\n\t<p>还有流式组合：</p>\n\t<pre lang='undefined'>\n\t<span>const</span> str=&quot;abcdaabc&quot;\n\t<span>const</span> res = str.<span>split</span>(&#39;&#39;)\n\t           .<span>reduce</span>((pre, cur) =&gt; (pre[cur]++ || (pre[cur] = 1), pre), {})\n\t</pre>\n\t<p><strong>结论</strong></p>\n\t<p>  函数式编程的可多次复用在代码的构建，测试和发布提现了明显的优势。</p>"},future:{type:"#奇说怪谈",isCenter:!1,title:"Future",content:"<p>This is my name，</p><p>I write a legend，however，</p><p>If I want，</p><p>No one can stop me，</p><p>And all from the darkness，</p><p>So I go，</p><p>Live or die，</p><p>let me choose.</p>"},es6:{type:"#ES6",isCenter:!0,title:"ECMAScript 6之艺术篇",content:"<h3>Map与Set</h3>\n\t<p>Map和Set都可以把类似数组结构的，通过扩展运算符转成数组，但set去掉重复的成员。代码如下：</p>\n\t<pre lang='undefined'>\n\t<span>const</span> set = <span>new</span> Set([1, 2, 3, 3]);\n\t[...set]   // [1, 2, ,3]\n\tset.<span>has</span>(1)  // true\n\tset.<span>add</span>(0) // [1, 2, 3, 0]\n\tset.<span>delete</span>(0) // true  表示是否删除成功\n\tset.<span>clear</span>() // 清除所有成员，无返回值\n\n\t<span>let</span> week = <span>new</span> Map([\n\t\t\t\t[ 0, &#39;星期日&#39; ],\n\t\t\t\t[ 6, &#39;星期六&#39; ]\n\t\t\t]);\n\t[...week]  // [[0, &#39;星期日&#39;], [6, &#39;星期六&#39;]]\n\t</pre>\n\t<p>Map和Set同样具有keys()、values()、entries()、forEach()三个遍历方法，以及size，clear()方法，不同的是Map的has(key)、delete(key)，而Set是针对value，has(value)、delete(value)。除此之外Map具有get(key)和set(key, value)，而Set是add(value)，它不具有get方法。代码如下：</p>\n\t<pre lang='undefined'>\n\t<span>let</span> week = <span>new</span> Map([\n\t\t\t[ 0, &#39;星期日&#39; ],\n\t\t\t[ 6, &#39;星期六&#39; ],\n\t\t\t[ 5, &#39;星期五&#39; ],\n\t\t\t[ 4, &#39;星期四&#39; ],\n\t\t\t[ 3, &#39;星期三&#39; ],\n\t\t\t[ 2, &#39;星期二&#39; ],\n\t\t\t[ 1, &#39;星期一&#39; ]\n\t]);\n\t<span>let</span> day = date.<span>getDay</span>();\n\t<span>for</span> (let [key, value] of week.<span>entries</span>()){\n\t\t<span>if</span>(key === day){\n\t\t\tday = value\n\t\t}\n\t}\n\tweek.<span>size</span>   //  7\n\tweek.<span>get</span>(0) // &#39;星期日&#39;\n\t</pre>\n\t<h3>Promise与Async</h3>\n\t<p><span>Promise</span>通俗来讲就是一个容器，里面通常是一个异步操作。它具有三种状态，<span>Pending</span>(进行中)、<span>Resolved</span>(已完成)、<span>Rejected</span>(已失败)。promise执行后只会在这三种状态中从Pending变为Resolved和从Pending变为Rejected。换句话说就像收快递一样，一旦发货无法取消，快递在发送时永远是发送中，直到快递到达某一站，更新下状态。这也算是promise的缺陷。</p>\n\t<pre lang='undefined'>\n\t<span>const</span> loadImg = <span>new</span> Promise((resolve, reject) => {\n\t   $.<span>ajax</span>({\n\t     url:&#39;....&#39;,\n\t     type:&#39;GET&#39;,\n\t     dataType:&#39;JSON&#39;,\n\t     success:(data)=>{\n\t        <span>resolve</span>(data);\n\t     }\n\t   })\n\t})\n\n\tloadImg.then((value)=>{console.log(value)})\n\t</pre>\n\t<p><span>then</span>方法相当于返回一个新的<span>Promise</span>实例，可以采用链式写法。<span>then</span>方法可以接受两个回调函数作为参数，分别是状态为Reject和Resolved时调用。resolve(new Promise())参数可以是另一个promise实例。</p>\n\t<h3>Promise.all()与Promise.race()</h3>\n\t<p>1、只有数组里的所有promise的状态都变成<span>resolved</span>，p的状态才会变成<span>resolved</span>，之后返回值会组成一个数组，再传递给p的回调函数；</p>\n\t<p>2、只要数组里其中有个promise被<span>rejected</span>，p的状态就会变成<span>rejected</span>，之后传递给p的回调函数</p>\n\t<pre lang='undefined'>\n\t<span>const</span> p = Promise.all([p1, p2, p3])\n\n\t//<span>Promise.all</span>接受一个数组作为参数，数组里的每个成员都是promise实例\n\n\t<span>const</span> p = Promise.race([p1, p2, p3])\n\t//只要数组成员中的一个实例率先改变状态，p的状态就会改变，率先改变的实例返回值将传递给p的回调函数。\n\t</pre>\n\t<h3>Async函数</h3>\n\t<p>将异步操作以同步的写法实现，避免了多层嵌套，使得异步操作更加方便，因为嵌套不但导致代码难读懂，而且维护起来比较绕，不直观。异步指得是一个任务分成两个过程，先执行第一个过程，然后可以去执行其他任务，等第一个过程准备完毕，再去执行第二个过程。</p>\n\t<pre lang='undefined'>\n\t<span>const</span> taskOne = <span>new</span> Promise((resolve, reject) => {\n\t  console.log(&#39;first task&#39;)\n\t  <span>resolve</span>();\n\t});\n\t<span>const</span> taskTwo = <span>new</span> Promise((resolve, reject) => {\n\t  console.log(&#39;second task&#39;)\n\t  <span>resolve</span>();\n\t});\n\t<span>const</span> timeout = <span>async</span> () => {\n\t  <span>await</span> taskOne;\n\t  <span>await</span> taskTwo;\n\t}\n\ttimeout().<span>then</span>(() =>{\n\t  console.log(&#39;well done&#39;)\n\t});\n\t</pre>\n\t<p>这个函数优雅快捷的取代了<span>Generator</span>函数以及<span>co</span>模块的结合写法。因为Generator函数是一个遍历器对象，自身不会自动执行，需要用到遍历器对象next方法，使得指针移向下一状态，通过yield暂停执行。而有了co模块就使得<span>Generator</span>能够自动执行。</p>\n\t<h3>Class与extends</h3>\n\t<p><span>Class</span>是ES6优雅的语法糖。更加像面向对象编程。</p>\n\t<pre lang='undefined'>\n\t<span>class</span> Person {\n\t  <span>constructor</span>(){\n\t    // ...\n\t  }\n\t  sayHi(){\n\n\t  }\n\t}\n\n\t// 等同于\n\t<span>function</span> Person(){}\n\tPerson.prototype = {\n\t  sayHi(){}\n\t};\n\t</pre>\n\t<p>所以方法是创建在原型上的，每个实例内部都不具有原型上的方法，因此方法不会被重复创建，与我另一篇《JavaScript原型篇》讲到的一样。</p>\n\t<p>接下来我们看下extends</p>\n\t<pre lang='undefined'>\n\t<span>class</span> Person { }\n\n\t<span>class</span> Tony <span>extends</span> Person {\n\t  <span>sconstructor</span>() {\n\t  \tsuper()\n\t  }\n\t}\n\n\t<span>let</span> man = <span>new</span> Tony();\n\n\tTony.__proto__ === Person // true\n\tTony.prototype.__proto__ === Person.prototype // true\n\t</pre>\n\t<p>子类必须在构造函数里调用super()方法，否则会报错。子类是没有this对象的，而是继承父类的this对象。</p>"},jsPrototype:{type:"#JavaScript",title:"JavaScript之原型篇",isCenter:"true",content:"<p>本文讲述通过构造函数、原型对象、原型链以及原型继承创建自定义类型的方法。</p>\n\t<h3><strong>构造函数</strong></h3>\n\t<p>​      函数还具备一种叫构造函数的使用。每个函数都会默认创建constructor，当然我们也可以自己去创建自定义的构造函数。如下代码所示：</p>\n\t<pre>\n\t<span>function</span> Person(name, age){\n\t    <span>this</span>.name = name;\n\t    <span>this</span>.age = age;\n\t    <span>this</span>.sayName = <span>function</span>(){\n\t        console.log(<span>this</span>.name);\n\t    };\n\t}\n\n\t<span>var</span> personOne = <span>new</span> Person(&quot;Tom&quot;, 16);\n\t<span>var</span> personTwo = <span>new</span> Person(&quot;Jack&quot;, 17);\n\tpersonOne.sayName();  // Tom\n\tpersonTwo.sayName();  // Jack\n\t</pre>\n\t<p>构造函数区别于其他函数的一点是在于他们的调用方式不同，需要new 一个对象来调用。于是我们可以观察到，每new一个person对象，都会在对象里创建于Person具有一样的属性和方法，如果创建多个对象，会重复创建sayName()方法。这样明显不好，于是想把sayName()这个方法抽离出来，能够使它只创建一次，但是抽出来后，发现这个sayName()方法是全局的，任何都可以调用到改方法，就没有封装思想可言。接下来我们来看下原型。</p>\n\t<h3><strong>Prototype</strong></h3>\n\t<p>每个函数创建后都有一个prototype属性。它可以实现所有对象实例共享它所包含的属性和方法，因此它就可以解决让每个实例都能调用到方法，且不会被重复创建。</p>\n\t<pre>\n\t<span>function</span> Person(){}\n\tPerson.prototype.name = &quot;Tony&quot;;\n\tPerson.prototype.age = 16;\n\tPerson.prototype.sayName = <span>function</span>(){\n\t  console.log(<span>this</span>.name);\n\t};\n\n\t<span>var</span> personOne = <span>new</span> Person();\n\t<span>var</span> personTwo = <span>new</span> Person();\n\n\tpersonOne.name = &quot;Tom&quot;;\n\tpersonOne.name;     // &quot;Tom&quot;，源于实例自身的name\n\tpersonTwo.name;     // &quot;Tony&quot;，源于原型的name\n\t</pre>\n\t<p>new出来的每个实例都会有个内部指针proto，指向Person.prototype。这个指针会先在实例内部检索属性和方法，如果没有检索到会往原型上继续检索，再没找到会继续往上找。从上面的代码，可以看出personOne修改name为Tom，而personTwo.name得到是Tony，因此personOne.name=&quot;Tom&quot;并没能修改到原型上的name。而是修改personOne自己的内部的name，咦，这样哪里有实例的属性和方法共享？对，我们现在只实现了方法不被重复创建。</p>\n\t<h3>构造函数与原型结合运用</h3>\n\t<pre>\n\t<span>function</span> Person(name, age){\n\t    <span>this</span>.name = name;\n\t    <span>this</span>.age = age;\n\t    <span>this</span>.skill = [&quot;run&quot;, &quot;say&quot;];\n\t}\n\n\tPerson.prototype = {\n\t    sayName : <span>function</span>(){\n\t        console.log(<span>this</span>.name);\n\t    }\n\t}\n\n\t<span>var</span> personOne = <span>new</span> Person(&quot;Tom&quot;, 17);\n\t<span>var</span> personTwo = <span>new</span> Person(&quot;Tony&quot;, 16,);\n\tpersonOne.skill.push(&quot;singing&quot;);\n\tpersonOne.skill // [&quot;run&quot;, &quot;say&quot;, &quot;singing&quot;]\n\tpersonTwo.skill // [&quot;run&quot;, &quot;say&quot;]\n\tpersonOne.sayName === personTwo.sayName  // true\n\t</pre>\n\t<p>这样一来，就可以实现每new一个对象都会具备构造函数的属性和方法，同时new出来的每个对象也都共享到原型上的属性和方法。</p>\n\t<h3>原型链</h3>\n\t<p>我们回顾下上面的代码，可以发现原型和实例与构造函数之间的关系链，每个构造函数都会有一个原型对象，原型对象有一个指向构造函数的指针，而通过构造函数实例出来的对象也有个内部指针，指向构造函数的原型对象。</p>\n\t<h3>原型继承</h3>\n\t<p>在ES6前，没有class和extends关键字去描述类与继承的关系，而是通过原型链来模拟继承，其实本质更像是重写原型对象的方法。如下代码所示：</p>\n\t<pre>\n\t<span>function</span> Animal(){\n\t    <span>this</span>.animalName = &#39;animal&#39;;\n\t}\n\tAnimal.prototype.getName = <span>function</span>(){\n\t    return <span>this</span>.animalName;\n\t};\n\n\t<span>function</span> Dog(){\n\t    <span>this</span>.dogName = &#39;dog&#39;;\n\t}\n\n\t// 继承了 Animal\n\tDog.prototype = <span>new</span> Animal();\n\n\tDog.prototype.getNameTwo = <span>function</span> (){\n\t    return <span>this</span>.dogName;\n\t};\n\n\t<span>var</span> dog = <span>new</span> Dog();\n\tdog.getName() // animal\n\tdog.getNameTwo() // dog\n\t</pre>"},vue:{type:"#Vue",title:"Vue 2.0双向绑定",isCenter:!0,content:"\n\t<p>\tVue整个框架都很不错，包括vuex，vue-router。这里就不再详细说明，因为vue官方文档写得挺不错的，而且是国人开发的，很容易读懂。有需要例子的可以到我的<a href='https://github.com/Damonlw'>github</a>上Fork，有完整的项目，若对你有帮助，还望Star一波，哈哈哈。</p>\n\t<p>\tvue2.0相比较vue1.0，除了实现虚拟DOM外，就是移除组件的<span>props</span>的双向绑定，变成需要自己手动绑定。我个人觉得这是个不错的改进，让结果更加唯一。ok，不吹了，我们进入代码环节。代码效果是当父亲说“I&#39;m comming home!”，孩子会回答“oh！dad.”当父亲说“I go to work.” 孩子会回答“Bye, dad.”</p>\n\t<pre lang='undefined'>\n\t&lt;template&gt;\n\t  &lt;div <span>id</span>=&quot;app&quot;&gt;\n\t    &lt;div  <span>class</span>=&quot;father&quot; <span>@click</span>=&quot;changeFatherStatus&quot;&gt;\n\t      Father: {{ status ? I'm comming home! : &#39;I go to work.&#39;}}\n\t    &lt;/div&gt;\n\t    &lt;child <span>@hug</span>=&quot;hug&quot; <span>:status</span>=&quot;status&quot;&gt;&lt;/child&gt;\n\t  &lt;/div&gt;\n\t&lt;/template&gt;\n\n\t&lt;script&gt;\n\t<span>import</span> child <span>from</span> &#39;./components/child&#39;\n\n\t<span>export</span> default {\n\t  <span>name</span>: &#39;app&#39;,\n\t  <span>data</span> () {\n\t    <span>return</span> {\n\t      status: true\n\t    }\n\t  },\n\t  <span>methods</span>: {\n\t    hug(value){\n\t      this.status = value;\n\t    },\n\t    changeFatherStatus(){\n\t      this.status = !this.status\n\t    }\n\t  },\n\t  <span>components</span>: {\n\t    child\n\t  }\n\t}\n\t&lt;/script&gt;\n\t</pre>\n\t<p>上面父组件通过props给child组件传递通信，以及一个改变父亲上下班状态的方法。</p>\n\t<pre lang='undefined'>\n\t&lt;template lang=&quot;html&quot;&gt;\n\t  &lt;div <span>class</span>=&quot;child&quot; <span>@click</span>=&quot;changeChildStatus&quot;&gt;\n\t  \tChild: {{ childStatus ? &#39;oh! dad.&#39;: &#39;Bye, dad.&#39;}}\n\t  &lt;/div&gt;\n\t&lt;/template&gt;\n\n\t&lt;script&gt;\n\t<span>export</span> default {\n\t\t<span>props</span>: [&#39;status&#39;],\n\t\t<span>data</span> () {\n\t\t\t<span>return</span> {\n\t\t\t\tchildStatus: this.status\n\t\t\t}\n\t\t},\n\t\t<span>watch</span>: {\n\t\t\tstatus(value) {\n\t\t\t\tthis.childStatus = value\n\t\t\t},\n\t\t\tchildStatus(value) {\n\t\t\t\tthis.<span>$emit</span>(&#39;hug&#39;, value)\n\t\t\t}\n\t\t},\n\t\t<span>methods</span>: {\n\t\t\tchangeChildStatus(){\n\t\t\t\tthis.childStatus = !this.childStatus\n\t\t\t}\n\t\t}\n\t}\n\t&lt;/script&gt;\n\t</pre>\n\t<p>\t上面则为子组件的内容，通过<span>props</span>接收父组件传递的内容，通过<span>watch</span>去监听，然后改变子组件孩子回答父亲的内容。但这里子组件也有绑定一个点击事件切换孩子回答的内容，这就变成孩子先说“Bye, dad.” 然后通过$emit反馈给父亲组件，父亲再说“I go to work.” </p>\n\t<p>\t当然父组件接受到子组件的反馈，也可以不作为，这就要看需求定。所以单单<span>props</span>或者<span>$emit</span>都是单向数据流。</p>"}};n.default=new r.default.Store({state:d,mutations:u.default,actions:c.default})},function(t,n,e){"use strict";function a(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var e in t)Object.prototype.hasOwnProperty.call(t,e)&&(n[e]=t[e]);return n.default=t,n}function s(t){return t&&t.__esModule?t:{default:t}}Object.defineProperty(n,"__esModule",{value:!0});var p=e(43),o=s(p),r=e(8),i=a(r);n.default=(0,o.default)({},i.GET_DATA,function(t,n){n.title===t.future.title?t.finalData=t.future:n.title===t.jsPrototype.title?t.finalData=t.jsPrototype:n.title===t.es6.title?t.finalData=t.es6:n.title===t.vue.title?t.finalData=t.vue:n.title===t.function.title?t.finalData=t.function:t.finalData="",t.scrollTop=n.top})}]);
//# sourceMappingURL=app.c3ebdad4fb0befe56ea7.js.map